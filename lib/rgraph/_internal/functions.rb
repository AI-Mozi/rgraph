require_relative "lib"
require_relative "enums"
require_relative "types"
require_relative "conversions"

require_relative "../graph"

# The rest of this file is generated by Stimulus

def empty(n_ = 0, directed = true)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_empty(c_graph, c_n, c_directed)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def add_edges(graph, edges)
  # Prepare input arguments
  c_graph = graph
  c_edges = vertex_pairs_to_igraph_vector_int_t(edges)
  c_attr = nil

  # Call wrapped function
  IgraphC.igraph_add_edges(c_graph, c_edges, c_attr)
end

def empty_attrs(n_, directed)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_directed = !!directed
  c_attr = nil

  # Call wrapped function
  IgraphC.igraph_empty_attrs(c_graph, c_n, c_directed, c_attr)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def add_vertices(graph, nv)
  # Prepare input arguments
  c_graph = graph
  c_nv = nv
  c_attr = nil

  # Call wrapped function
  IgraphC.igraph_add_vertices(c_graph, c_nv, c_attr)
end

def copy(from)
  # Prepare input arguments
  c_to = RGraph::Internal::Graph.new
  c_from = from

  # Call wrapped function
  IgraphC.igraph_copy(c_to, c_from)

  # Prepare output arguments
  to = RGraph::Graph.new(_wrap: c_to)

  # Construct return value
  to
end

def delete_edges(graph, edges)
  # Prepare input arguments
  c_graph = graph
  c_edges = edge_selector_to_igraph_es_t(edges, graph)

  # Call wrapped function
  IgraphC.igraph_delete_edges(c_graph, c_edges.unwrap())
end

def delete_vertices(graph, vertices)
  # Prepare input arguments
  c_graph = graph
  c_vertices = vertex_selector_to_igraph_vs_t(vertices, graph)

  # Call wrapped function
  IgraphC.igraph_delete_vertices(c_graph, c_vertices.unwrap())
end

# igraph_delete_vertices_idx: no Ruby type known for type: VECTOR_INT

def vcount(graph)
  # Prepare input arguments
  c_graph = graph

  # Call wrapped function
  c__result = IgraphC.igraph_vcount(c_graph)

  # Construct return value
  c__result
end

def ecount(graph)
  # Prepare input arguments
  c_graph = graph

  # Call wrapped function
  c__result = IgraphC.igraph_ecount(c_graph)

  # Construct return value
  c__result
end

def neighbors(graph, vid, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = graph
  c_neis = _VectorInt.create(0)
  c_vid = vertexlike_to_igraph_integer_t(vid)
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_neighbors(c_graph, c_neis, c_vid, c_mode)

  # Prepare output arguments
  neis = igraph_vector_int_t_to_numpy_array(c_neis)

  # Construct return value
  neis
end

def is_directed(graph)
  # Prepare input arguments
  c_graph = graph

  # Call wrapped function
  c__result = IgraphC.igraph_is_directed(c_graph)

  # Construct return value
  c__result
end

# igraph_degree: no Ruby type known for type: VECTOR_INT

def edge(graph, eid)
  # Prepare input arguments
  c_graph = graph
  c_eid = eid
  c_from = nil
  c_to = nil

  # Call wrapped function
  IgraphC.igraph_edge(c_graph, c_eid, c_from, c_to)

  # Prepare output arguments
  from = c_from.value
  to = c_to.value

  # Construct return value
  return from, to
end

# igraph_edges: no Ruby type known for type: VECTOR_INT

def get_eid(graph, from, to, directed = true, error = true)
  # Prepare input arguments
  c_graph = graph
  c_eid = igraph_integer_t(0)
  c_from = vertexlike_to_igraph_integer_t(from)
  c_to = vertexlike_to_igraph_integer_t(to)
  c_directed = !!directed
  c_error = !!error

  # Call wrapped function
  IgraphC.igraph_get_eid(c_graph, c_eid, c_from, c_to, c_directed, c_error)

  # Prepare output arguments
  eid = c_eid.value

  # Construct return value
  eid
end

def get_eids(graph, pairs, directed = true, error = true)
  # Prepare input arguments
  c_graph = graph
  c_eids = _VectorInt.create(0)
  c_pairs = vertex_pairs_to_igraph_vector_int_t(pairs)
  c_directed = !!directed
  c_error = !!error

  # Call wrapped function
  IgraphC.igraph_get_eids(c_graph, c_eids, c_pairs, c_directed, c_error)

  # Prepare output arguments
  eids = igraph_vector_int_t_to_numpy_array(c_eids)

  # Construct return value
  eids
end

def get_all_eids_between(graph, from, to, directed = true)
  # Prepare input arguments
  c_graph = graph
  c_eids = _VectorInt.create(0)
  c_from = vertexlike_to_igraph_integer_t(from)
  c_to = vertexlike_to_igraph_integer_t(to)
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_get_all_eids_between(c_graph, c_eids, c_from, c_to, c_directed)

  # Prepare output arguments
  eids = igraph_vector_int_t_to_numpy_array(c_eids)

  # Construct return value
  eids
end

def incident(graph, vid, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = graph
  c_eids = _VectorInt.create(0)
  c_vid = vertexlike_to_igraph_integer_t(vid)
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_incident(c_graph, c_eids, c_vid, c_mode)

  # Prepare output arguments
  eids = igraph_vector_int_t_to_numpy_array(c_eids)

  # Construct return value
  eids
end

def is_same_graph(graph1, graph2)
  # Prepare input arguments
  c_graph1 = graph1
  c_graph2 = graph2
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_same_graph(c_graph1, c_graph2, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_create: no Ruby type known for type: VECTOR_INT

# igraph_adjacency: no Ruby type known for type: MATRIX

# igraph_sparse_adjacency: no Ruby type known for type: SPARSEMAT

# igraph_sparse_weighted_adjacency: no Ruby type known for type: SPARSEMAT

# igraph_weighted_adjacency: no Ruby type known for type: MATRIX

def star(n_, mode = StarMode::OUT, center = 0)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_mode = mode
  c_center = center

  # Call wrapped function
  IgraphC.igraph_star(c_graph, c_n, c_mode, c_center)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def wheel(n_, mode = WheelMode::OUT, center = 0)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_mode = mode
  c_center = center

  # Call wrapped function
  IgraphC.igraph_wheel(c_graph, c_n, c_mode, c_center)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def hypercube(n_, directed = false)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_hypercube(c_graph, c_n, c_directed)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_square_lattice: no Ruby type known for type: VECTOR_INT

# igraph_triangular_lattice: no Ruby type known for type: VECTOR_INT

def ring(n_, directed = false, mutual = false, circular = true)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_directed = !!directed
  c_mutual = !!mutual
  c_circular = !!circular

  # Call wrapped function
  IgraphC.igraph_ring(c_graph, c_n, c_directed, c_mutual, c_circular)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def kary_tree(n_, children = 2, type = TreeMode::OUT)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_children = children
  c_type = type

  # Call wrapped function
  IgraphC.igraph_kary_tree(c_graph, c_n, c_children, c_type)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_symmetric_tree: no Ruby type known for type: VECTOR_INT

def regular_tree(h, k = 3, type = TreeMode::UNDIRECTED)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_h = h
  c_k = k
  c_type = type

  # Call wrapped function
  IgraphC.igraph_regular_tree(c_graph, c_h, c_k, c_type)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def full(n_, directed = false, loops = false)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_directed = !!directed
  c_loops = !!loops

  # Call wrapped function
  IgraphC.igraph_full(c_graph, c_n, c_directed, c_loops)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def full_citation(n_, directed = true)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_full_citation(c_graph, c_n, c_directed)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def atlas(number = 0)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_number = number

  # Call wrapped function
  IgraphC.igraph_atlas(c_graph, c_number)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_extended_chordal_ring: no Ruby type known for type: MATRIX_INT

def connect_neighborhood(graph, order = 2, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = graph
  c_order = order
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_connect_neighborhood(c_graph, c_order, c_mode)
end

def graph_power(graph, order, directed = false)
  # Prepare input arguments
  c_graph = graph
  c_res = RGraph::Internal::Graph.new
  c_order = order
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_graph_power(c_graph, c_res, c_order, c_directed)

  # Prepare output arguments
  res = RGraph::Graph.new(_wrap: c_res)

  # Construct return value
  res
end

def linegraph(graph)
  # Prepare input arguments
  c_graph = graph
  c_linegraph = RGraph::Internal::Graph.new

  # Call wrapped function
  IgraphC.igraph_linegraph(c_graph, c_linegraph)

  # Prepare output arguments
  linegraph = RGraph::Graph.new(_wrap: c_linegraph)

  # Construct return value
  linegraph
end

def de_bruijn(m, n_)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_m = m
  c_n = n_

  # Call wrapped function
  IgraphC.igraph_de_bruijn(c_graph, c_m, c_n)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def kautz(m, n_)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_m = m
  c_n = n_

  # Call wrapped function
  IgraphC.igraph_kautz(c_graph, c_m, c_n)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def famous(name)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_name = name.encode("utf-8")

  # Call wrapped function
  IgraphC.igraph_famous(c_graph, c_name)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_lcf_vector: no Ruby type known for type: VECTOR_INT

# igraph_adjlist: no Ruby type known for type: ADJLIST

def full_bipartite(n1, n2, directed = false, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_types = _VectorBool.create(0)
  c_n1 = n1
  c_n2 = n2
  c_directed = !!directed
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_full_bipartite(c_graph, c_types, c_n1, c_n2, c_directed, c_mode)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)
  types = c_types.value

  # Construct return value
  return graph, types
end

# igraph_full_multipartite: no Ruby type known for type: INDEX_VECTOR

# igraph_realize_degree_sequence: no Ruby type known for type: VECTOR_INT

# igraph_realize_bipartite_degree_sequence: no Ruby type known for type: VECTOR_INT

# igraph_circulant: no Ruby type known for type: VECTOR_INT

def generalized_petersen(n_, k)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_k = k

  # Call wrapped function
  IgraphC.igraph_generalized_petersen(c_graph, c_n, c_k)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_turan: no Ruby type known for type: INDEX_VECTOR

# igraph_weighted_sparsemat: no Ruby type known for type: SPARSEMAT

# igraph_barabasi_game: no Ruby type known for type: VECTOR_INT

def erdos_renyi_game_gnp(n_, p, directed = false, loops = false)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_p = p
  c_directed = !!directed
  c_loops = !!loops

  # Call wrapped function
  IgraphC.igraph_erdos_renyi_game_gnp(c_graph, c_n, c_p, c_directed, c_loops)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def erdos_renyi_game_gnm(n_, m, directed = false, loops = false)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_m = m
  c_directed = !!directed
  c_loops = !!loops

  # Call wrapped function
  IgraphC.igraph_erdos_renyi_game_gnm(c_graph, c_n, c_m, c_directed, c_loops)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_degree_sequence_game: no Ruby type known for type: VECTOR_INT

def growing_random_game(n_, m = 1, directed = false, citation = false)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_m = m
  c_directed = !!directed
  c_citation = !!citation

  # Call wrapped function
  IgraphC.igraph_growing_random_game(c_graph, c_n, c_m, c_directed, c_citation)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_barabasi_aging_game: no Ruby type known for type: VECTOR_INT

# igraph_recent_degree_game: no Ruby type known for type: VECTOR_INT

# igraph_recent_degree_aging_game: no Ruby type known for type: VECTOR_INT

# igraph_callaway_traits_game: no Ruby type known for type: VECTOR

# igraph_establishment_game: no Ruby type known for type: VECTOR

# igraph_grg_game: no Ruby type known for type: VECTOR

# igraph_preference_game: no Ruby type known for type: VECTOR

# igraph_asymmetric_preference_game: no Ruby type known for type: MATRIX

def rewire_edges(graph, prob, loops = false, multiple = false)
  # Prepare input arguments
  c_graph = graph
  c_prob = prob
  c_loops = !!loops
  c_multiple = !!multiple

  # Call wrapped function
  IgraphC.igraph_rewire_edges(c_graph, c_prob, c_loops, c_multiple)
end

def rewire_directed_edges(graph, prob, loops = false, mode = NeighborMode::OUT)
  # Prepare input arguments
  c_graph = graph
  c_prob = prob
  c_loops = !!loops
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_rewire_directed_edges(c_graph, c_prob, c_loops, c_mode)
end

def watts_strogatz_game(dim, size, nei, p, loops = false, multiple = false)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_dim = dim
  c_size = size
  c_nei = nei
  c_p = p
  c_loops = !!loops
  c_multiple = !!multiple

  # Call wrapped function
  IgraphC.igraph_watts_strogatz_game(c_graph, c_dim, c_size, c_nei, c_p, c_loops, c_multiple)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_lastcit_game: no Ruby type known for type: VECTOR

# igraph_cited_type_game: no Ruby type known for type: INDEX_VECTOR

# igraph_citing_cited_type_game: no Ruby type known for type: INDEX_VECTOR

def forest_fire_game(nodes, fw_prob, bw_factor = 1, ambs = 1, directed = true)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_nodes = nodes
  c_fw_prob = fw_prob
  c_bw_factor = bw_factor
  c_ambs = ambs
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_forest_fire_game(c_graph, c_nodes, c_fw_prob, c_bw_factor, c_ambs, c_directed)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def simple_interconnected_islands_game(islands_n, islands_size, islands_pin, n_inter)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_islands_n = islands_n
  c_islands_size = islands_size
  c_islands_pin = islands_pin
  c_n_inter = n_inter

  # Call wrapped function
  IgraphC.igraph_simple_interconnected_islands_game(c_graph, c_islands_n, c_islands_size, c_islands_pin, c_n_inter)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_chung_lu_game: no Ruby type known for type: VECTOR

# igraph_static_fitness_game: no Ruby type known for type: VECTOR

def static_power_law_game(no_of_nodes, no_of_edges, exponent_out, exponent_in = -1, loops = false, multiple = false, finite_size_correction = true)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_no_of_nodes = no_of_nodes
  c_no_of_edges = no_of_edges
  c_exponent_out = exponent_out
  c_exponent_in = exponent_in
  c_loops = !!loops
  c_multiple = !!multiple
  c_finite_size_correction = !!finite_size_correction

  # Call wrapped function
  IgraphC.igraph_static_power_law_game(c_graph, c_no_of_nodes, c_no_of_edges, c_exponent_out, c_exponent_in, c_loops, c_multiple, c_finite_size_correction)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def k_regular_game(no_of_nodes, k, directed = false, multiple = false)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_no_of_nodes = no_of_nodes
  c_k = k
  c_directed = !!directed
  c_multiple = !!multiple

  # Call wrapped function
  IgraphC.igraph_k_regular_game(c_graph, c_no_of_nodes, c_k, c_directed, c_multiple)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_sbm_game: no Ruby type known for type: MATRIX

# igraph_hsbm_game: no Ruby type known for type: VECTOR

# igraph_hsbm_list_game: no Ruby type known for type: VECTOR_INT

# igraph_correlated_game: no Ruby type known for type: INDEX_VECTOR

# igraph_correlated_pair_game: no Ruby type known for type: INDEX_VECTOR

# igraph_dot_product_game: no Ruby type known for type: MATRIX

# igraph_sample_sphere_surface: no Ruby type known for type: MATRIX

# igraph_sample_sphere_volume: no Ruby type known for type: MATRIX

# igraph_sample_dirichlet: no Ruby type known for type: VECTOR

def are_adjacent(graph, v1, v2)
  # Prepare input arguments
  c_graph = graph
  c_v1 = vertexlike_to_igraph_integer_t(v1)
  c_v2 = vertexlike_to_igraph_integer_t(v2)
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_are_adjacent(c_graph, c_v1, c_v2, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def are_connected(graph, v1, v2)
  # Prepare input arguments
  c_graph = graph
  c_v1 = vertexlike_to_igraph_integer_t(v1)
  c_v2 = vertexlike_to_igraph_integer_t(v2)
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_are_connected(c_graph, c_v1, c_v2, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_diameter: no Ruby type known for type: VECTOR_INT

# igraph_diameter_dijkstra: no Ruby type known for type: EDGEWEIGHTS

# igraph_closeness: no Ruby type known for type: VERTEX_QTY

# igraph_closeness_cutoff: no Ruby type known for type: VERTEX_QTY

# igraph_distances: no Ruby type known for type: MATRIX

# igraph_distances_cutoff: no Ruby type known for type: MATRIX

def get_shortest_path(graph, from, to, mode = NeighborMode::OUT)
  # Prepare input arguments
  c_graph = graph
  c_vertices = _VectorInt.create(0)
  c_edges = _VectorInt.create(0)
  c_from = vertexlike_to_igraph_integer_t(from)
  c_to = vertexlike_to_igraph_integer_t(to)
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_get_shortest_path(c_graph, c_vertices, c_edges, c_from, c_to, c_mode)

  # Prepare output arguments
  vertices = igraph_vector_int_t_to_numpy_array(c_vertices)
  edges = igraph_vector_int_t_to_numpy_array(c_edges)

  # Construct return value
  return vertices, edges
end

# igraph_get_shortest_path_bellman_ford: no Ruby type known for type: EDGEWEIGHTS

# igraph_get_shortest_path_dijkstra: no Ruby type known for type: EDGEWEIGHTS

# igraph_get_shortest_path_astar: no Ruby type known for type: EDGEWEIGHTS

# igraph_get_shortest_paths: no Ruby type known for type: VERTEXSET_LIST

# igraph_get_all_shortest_paths: no Ruby type known for type: VERTEXSET_LIST

# igraph_distances_dijkstra: no Ruby type known for type: MATRIX

# igraph_distances_dijkstra_cutoff: no Ruby type known for type: MATRIX

# igraph_get_shortest_paths_dijkstra: no Ruby type known for type: VERTEXSET_LIST

# igraph_get_shortest_paths_bellman_ford: no Ruby type known for type: VERTEXSET_LIST

# igraph_get_all_shortest_paths_dijkstra: no Ruby type known for type: VERTEXSET_LIST

# igraph_distances_bellman_ford: no Ruby type known for type: MATRIX

# igraph_distances_johnson: no Ruby type known for type: MATRIX

# igraph_distances_floyd_warshall: no Ruby type known for type: MATRIX

# igraph_voronoi: no Ruby type known for type: VECTOR_INT

def get_all_simple_paths(graph, from, to = "all", cutoff = -1, mode = NeighborMode::OUT)
  # Prepare input arguments
  c_graph = graph
  c_res = _VectorInt.create(0)
  c_from = vertexlike_to_igraph_integer_t(from)
  c_to = vertex_selector_to_igraph_vs_t(to, graph)
  c_cutoff = cutoff
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_get_all_simple_paths(c_graph, c_res, c_from, c_to.unwrap(), c_cutoff, c_mode)

  # Prepare output arguments
  res = igraph_vector_int_t_to_numpy_array(c_res)

  # Construct return value
  res
end

# igraph_get_k_shortest_paths: no Ruby type known for type: EDGEWEIGHTS

# igraph_get_widest_path: no Ruby type known for type: EDGEWEIGHTS

# igraph_get_widest_paths: no Ruby type known for type: VERTEXSET_LIST

# igraph_widest_path_widths_dijkstra: no Ruby type known for type: MATRIX

# igraph_widest_path_widths_floyd_warshall: no Ruby type known for type: MATRIX

# igraph_spanner: no Ruby type known for type: EDGEWEIGHTS

def subcomponent(graph, vid, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = graph
  c_res = _VectorInt.create(0)
  c_vid = vertexlike_to_igraph_integer_t(vid)
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_subcomponent(c_graph, c_res, c_vid, c_mode)

  # Prepare output arguments
  res = igraph_vector_int_t_to_numpy_array(c_res)

  # Construct return value
  res
end

# igraph_betweenness: no Ruby type known for type: VERTEX_QTY

# igraph_betweenness_cutoff: no Ruby type known for type: VERTEX_QTY

# igraph_betweenness_subset: no Ruby type known for type: VERTEX_QTY

# igraph_edge_betweenness: no Ruby type known for type: VECTOR

# igraph_edge_betweenness_cutoff: no Ruby type known for type: VECTOR

# igraph_edge_betweenness_subset: no Ruby type known for type: VECTOR

# igraph_harmonic_centrality: no Ruby type known for type: VERTEX_QTY

# igraph_harmonic_centrality_cutoff: no Ruby type known for type: VERTEX_QTY

# igraph_pagerank: no Ruby type known for type: VERTEX_QTY

# igraph_personalized_pagerank: no Ruby type known for type: VERTEX_QTY

# igraph_personalized_pagerank_vs: no Ruby type known for type: VERTEX_QTY

def rewire(rewire, n_, mode = Rewiring::SIMPLE)
  # Prepare input arguments
  c_rewire = rewire
  c_n = n_
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_rewire(c_rewire, c_n, c_mode)
end

def induced_subgraph(graph, vids, impl = SubgraphImplementation::AUTO)
  # Prepare input arguments
  c_graph = graph
  c_res = RGraph::Internal::Graph.new
  c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
  c_impl = impl

  # Call wrapped function
  IgraphC.igraph_induced_subgraph(c_graph, c_res, c_vids.unwrap(), c_impl)

  # Prepare output arguments
  res = RGraph::Graph.new(_wrap: c_res)

  # Construct return value
  res
end

def subgraph_from_edges(graph, eids, delete_vertices = true)
  # Prepare input arguments
  c_graph = graph
  c_res = RGraph::Internal::Graph.new
  c_eids = edge_selector_to_igraph_es_t(eids, graph)
  c_delete_vertices = !!delete_vertices

  # Call wrapped function
  IgraphC.igraph_subgraph_from_edges(c_graph, c_res, c_eids.unwrap(), c_delete_vertices)

  # Prepare output arguments
  res = RGraph::Graph.new(_wrap: c_res)

  # Construct return value
  res
end

def reverse_edges(graph, eids = "all")
  # Prepare input arguments
  c_graph = graph
  c_eids = edge_selector_to_igraph_es_t(eids, graph)

  # Call wrapped function
  IgraphC.igraph_reverse_edges(c_graph, c_eids.unwrap())
end

def average_path_length(graph, directed = true, unconn = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_unconn_pairs = nil
  c_directed = !!directed
  c_unconn = !!unconn

  # Call wrapped function
  IgraphC.igraph_average_path_length(c_graph, c_res, c_unconn_pairs, c_directed, c_unconn)

  # Prepare output arguments
  res = c_res.value
  unconn_pairs = c_unconn_pairs.value

  # Construct return value
  return res, unconn_pairs
end

# igraph_average_path_length_dijkstra: no Ruby type known for type: EDGEWEIGHTS

# igraph_path_length_hist: no Ruby type known for type: VECTOR

def simplify(graph, remove_multiple = true, remove_loops = true, edge_attr_comb = None)
  # Prepare input arguments
  c_graph = graph
  c_remove_multiple = !!remove_multiple
  c_remove_loops = !!remove_loops
  c_edge_attr_comb = mapping_to_attribute_combination_t(edge_attr_comb)

  # Call wrapped function
  IgraphC.igraph_simplify(c_graph, c_remove_multiple, c_remove_loops, c_edge_attr_comb)
end

def transitivity_undirected(graph, mode = TransitivityMode::NAN)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_transitivity_undirected(c_graph, c_res, c_mode)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_transitivity_local_undirected: no Ruby type known for type: VECTOR

def transitivity_avglocal_undirected(graph, mode = TransitivityMode::NAN)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_transitivity_avglocal_undirected(c_graph, c_res, c_mode)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_transitivity_barrat: no Ruby type known for type: VECTOR

# igraph_ecc: no Ruby type known for type: VECTOR

def reciprocity(graph, ignore_loops = true, mode = Reciprocity::DEFAULT)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_ignore_loops = !!ignore_loops
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_reciprocity(c_graph, c_res, c_ignore_loops, c_mode)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_constraint: no Ruby type known for type: VECTOR

def maxdegree(graph, vids = "all", mode = NeighborMode::ALL, loops = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_vids = vertex_selector_to_igraph_vs_t(vids, graph)
  c_mode = mode
  c_loops = !!loops

  # Call wrapped function
  IgraphC.igraph_maxdegree(c_graph, c_res, c_vids.unwrap(), c_mode, c_loops)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def density(graph, loops = false)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_loops = !!loops

  # Call wrapped function
  IgraphC.igraph_density(c_graph, c_res, c_loops)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def mean_degree(graph, loops = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_loops = !!loops

  # Call wrapped function
  IgraphC.igraph_mean_degree(c_graph, c_res, c_loops)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_neighborhood_size: no Ruby type known for type: VECTOR_INT

# igraph_neighborhood: no Ruby type known for type: VERTEXSET_LIST

# igraph_neighborhood_graphs: no Ruby type known for type: GRAPH_LIST

# igraph_topological_sorting: no Ruby type known for type: VECTOR_INT

# igraph_feedback_arc_set: no Ruby type known for type: EDGEWEIGHTS

# igraph_is_loop: no Ruby type known for type: VECTOR_BOOL

def is_dag(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_dag(c_graph, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def is_acyclic(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_acyclic(c_graph, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def is_simple(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_simple(c_graph, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_is_multiple: no Ruby type known for type: VECTOR_BOOL

def has_loop(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_has_loop(c_graph, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def has_multiple(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_has_multiple(c_graph, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def count_loops(graph)
  # Prepare input arguments
  c_graph = graph
  c_loop_count = nil

  # Call wrapped function
  IgraphC.igraph_count_loops(c_graph, c_loop_count)

  # Prepare output arguments
  loop_count = c_loop_count.value

  # Construct return value
  loop_count
end

# igraph_count_multiple: no Ruby type known for type: VECTOR_INT

def girth(graph)
  # Prepare input arguments
  c_graph = graph
  c_girth = nil
  c_circle = _VectorInt.create(0)

  # Call wrapped function
  IgraphC.igraph_girth(c_graph, c_girth, c_circle)

  # Prepare output arguments
  girth = c_girth.value
  circle = igraph_vector_int_t_to_numpy_array(c_circle)

  # Construct return value
  return girth, circle
end

def is_perfect(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_perfect(c_graph, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def add_edge(graph, from, to)
  # Prepare input arguments
  c_graph = graph
  c_from = from
  c_to = to

  # Call wrapped function
  IgraphC.igraph_add_edge(c_graph, c_from, c_to)
end

# igraph_eigenvector_centrality: no Ruby type known for type: ALL_VERTEX_QTY

# igraph_hub_score: no Ruby type known for type: ALL_VERTEX_QTY

# igraph_authority_score: no Ruby type known for type: ALL_VERTEX_QTY

# igraph_hub_and_authority_scores: no Ruby type known for type: ALL_VERTEX_QTY

# igraph_unfold_tree: no Ruby type known for type: VECTOR_INT

# igraph_is_mutual: no Ruby type known for type: VECTOR_BOOL

def has_mutual(graph, loops = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_loops = !!loops

  # Call wrapped function
  IgraphC.igraph_has_mutual(c_graph, c_res, c_loops)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_maximum_cardinality_search: no Ruby type known for type: INDEX_VECTOR

# igraph_is_chordal: no Ruby type known for type: INDEX_VECTOR

# igraph_avg_nearest_neighbor_degree: no Ruby type known for type: VERTEX_QTY

# igraph_degree_correlation_vector: no Ruby type known for type: EDGEWEIGHTS

# igraph_strength: no Ruby type known for type: VERTEX_QTY

# igraph_centralization: no Ruby type known for type: VECTOR

# igraph_centralization_degree: no Ruby type known for type: VECTOR

def centralization_degree_tmax(loops, graph = nil, nodes = 0, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = graph if graph
  c_nodes = nodes
  c_mode = mode
  c_loops = !!loops
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_centralization_degree_tmax(c_graph, c_nodes, c_mode, c_loops, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_centralization_betweenness: no Ruby type known for type: VECTOR

def centralization_betweenness_tmax(graph = nil, nodes = 0, directed = true)
  # Prepare input arguments
  c_graph = graph if graph
  c_nodes = nodes
  c_directed = !!directed
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_centralization_betweenness_tmax(c_graph, c_nodes, c_directed, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_centralization_closeness: no Ruby type known for type: VECTOR

def centralization_closeness_tmax(graph = nil, nodes = 0, mode = NeighborMode::OUT)
  # Prepare input arguments
  c_graph = graph if graph
  c_nodes = nodes
  c_mode = mode
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_centralization_closeness_tmax(c_graph, c_nodes, c_mode, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_centralization_eigenvector_centrality: no Ruby type known for type: VECTOR

def centralization_eigenvector_centrality_tmax(graph = nil, nodes = 0, directed = false, scale = true)
  # Prepare input arguments
  c_graph = graph if graph
  c_nodes = nodes
  c_directed = !!directed
  c_scale = !!scale
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_centralization_eigenvector_centrality_tmax(c_graph, c_nodes, c_directed, c_scale, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_assortativity_nominal: no Ruby type known for type: INDEX_VECTOR

# igraph_assortativity: no Ruby type known for type: VECTOR

def assortativity_degree(graph, directed = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_assortativity_degree(c_graph, c_res, c_directed)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_joint_degree_matrix: no Ruby type known for type: EDGEWEIGHTS

# igraph_joint_degree_distribution: no Ruby type known for type: EDGEWEIGHTS

# igraph_joint_type_distribution: no Ruby type known for type: EDGEWEIGHTS

# igraph_contract_vertices: no Ruby type known for type: INDEX_VECTOR

# igraph_eccentricity: no Ruby type known for type: VERTEX_QTY

# igraph_eccentricity_dijkstra: no Ruby type known for type: EDGEWEIGHTS

def graph_center(graph, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = graph
  c_res = _VectorInt.create(0)
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_graph_center(c_graph, c_res, c_mode)

  # Prepare output arguments
  res = igraph_vector_int_t_to_numpy_array(c_res)

  # Construct return value
  res
end

# igraph_graph_center_dijkstra: no Ruby type known for type: EDGEWEIGHTS

def radius(graph, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = graph
  c_radius = nil
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_radius(c_graph, c_radius, c_mode)

  # Prepare output arguments
  radius = c_radius.value

  # Construct return value
  radius
end

# igraph_radius_dijkstra: no Ruby type known for type: EDGEWEIGHTS

def pseudo_diameter(graph, start_vid, directed = true, unconnected = true)
  # Prepare input arguments
  c_graph = graph
  c_diameter = nil
  c_start_vid = vertexlike_to_igraph_integer_t(start_vid)
  c_from = nil
  c_to = nil
  c_directed = !!directed
  c_unconnected = !!unconnected

  # Call wrapped function
  IgraphC.igraph_pseudo_diameter(c_graph, c_diameter, c_start_vid, c_from, c_to, c_directed, c_unconnected)

  # Prepare output arguments
  diameter = c_diameter.value
  from = c_from.value
  to = c_to.value

  # Construct return value
  return diameter, from, to
end

# igraph_pseudo_diameter_dijkstra: no Ruby type known for type: EDGEWEIGHTS

# igraph_diversity: no Ruby type known for type: EDGEWEIGHTS

# igraph_random_walk: no Ruby type known for type: EDGEWEIGHTS

# igraph_random_edge_walk: no Ruby type known for type: EDGEWEIGHTS

# igraph_global_efficiency: no Ruby type known for type: EDGEWEIGHTS

# igraph_local_efficiency: no Ruby type known for type: VERTEX_QTY

# igraph_average_local_efficiency: no Ruby type known for type: EDGEWEIGHTS

def transitive_closure_dag(graph)
  # Prepare input arguments
  c_graph = graph
  c_closure = RGraph::Internal::Graph.new

  # Call wrapped function
  IgraphC.igraph_transitive_closure_dag(c_graph, c_closure)

  # Prepare output arguments
  closure = RGraph::Graph.new(_wrap: c_closure)

  # Construct return value
  closure
end

def transitive_closure(graph)
  # Prepare input arguments
  c_graph = graph
  c_closure = RGraph::Internal::Graph.new

  # Call wrapped function
  IgraphC.igraph_transitive_closure(c_graph, c_closure)

  # Prepare output arguments
  closure = RGraph::Graph.new(_wrap: c_closure)

  # Construct return value
  closure
end

# igraph_trussness: no Ruby type known for type: VECTOR_INT

# igraph_is_bigraphical: no Ruby type known for type: VECTOR_INT

# igraph_is_graphical: no Ruby type known for type: VECTOR_INT

# igraph_bfs: no Ruby type known for type: VECTOR_INT

# igraph_bfs_simple: no Ruby type known for type: VECTOR_INT

# igraph_dfs: no Ruby type known for type: VECTOR_INT

def bipartite_projection_size(graph, types = NULL)
  # Prepare input arguments
  c_graph = graph
  c_types = iterable_to_igraph_vector_bool_t_view(types)
  c_vcount1 = nil
  c_ecount1 = nil
  c_vcount2 = nil
  c_ecount2 = nil

  # Call wrapped function
  IgraphC.igraph_bipartite_projection_size(c_graph, c_types, c_vcount1, c_ecount1, c_vcount2, c_ecount2)

  # Prepare output arguments
  vcount1 = c_vcount1.value
  ecount1 = c_ecount1.value
  vcount2 = c_vcount2.value
  ecount2 = c_ecount2.value

  # Construct return value
  return vcount1, ecount1, vcount2, ecount2
end

# igraph_bipartite_projection: no Ruby type known for type: VECTOR_INT

# igraph_create_bipartite: no Ruby type known for type: VECTOR_INT

# igraph_biadjacency: no Ruby type known for type: MATRIX

# igraph_get_biadjacency: no Ruby type known for type: MATRIX

def is_bipartite(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_type = _VectorBool.create(0)

  # Call wrapped function
  IgraphC.igraph_is_bipartite(c_graph, c_res, c_type)

  # Prepare output arguments
  res = c_res.value
  type = c_type.value

  # Construct return value
  return res, type
end

def bipartite_game_gnp(n1, n2, p, directed = false, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_types = _VectorBool.create(0)
  c_n1 = n1
  c_n2 = n2
  c_p = p
  c_directed = !!directed
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_bipartite_game_gnp(c_graph, c_types, c_n1, c_n2, c_p, c_directed, c_mode)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)
  types = c_types.value

  # Construct return value
  return graph, types
end

def bipartite_game_gnm(n1, n2, m, directed = false, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_types = _VectorBool.create(0)
  c_n1 = n1
  c_n2 = n2
  c_m = m
  c_directed = !!directed
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_bipartite_game_gnm(c_graph, c_types, c_n1, c_n2, c_m, c_directed, c_mode)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)
  types = c_types.value

  # Construct return value
  return graph, types
end

def bipartite_game(type, n1, n2, p = 0.0, m = 0, directed = false, mode = NeighborMode::ALL)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_types = _VectorBool.create(0)
  c_type = type
  c_n1 = n1
  c_n2 = n2
  c_p = p
  c_m = m
  c_directed = !!directed
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_bipartite_game(c_graph, c_types, c_type, c_n1, c_n2, c_p, c_m, c_directed, c_mode)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)
  types = c_types.value

  # Construct return value
  return graph, types
end

# igraph_get_laplacian: no Ruby type known for type: MATRIX

# igraph_get_laplacian_sparse: no Ruby type known for type: SPARSEMAT

# igraph_connected_components: no Ruby type known for type: VECTOR_INT

def is_connected(graph, mode = Connectedness::WEAK)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_is_connected(c_graph, c_res, c_mode)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_decompose: no Ruby type known for type: GRAPH_LIST

def articulation_points(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = _VectorInt.create(0)

  # Call wrapped function
  IgraphC.igraph_articulation_points(c_graph, c_res)

  # Prepare output arguments
  res = igraph_vector_int_t_to_numpy_array(c_res)

  # Construct return value
  res
end

# igraph_biconnected_components: no Ruby type known for type: EDGESET_LIST

def bridges(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = _VectorInt.create(0)

  # Call wrapped function
  IgraphC.igraph_bridges(c_graph, c_res)

  # Prepare output arguments
  res = igraph_vector_int_t_to_numpy_array(c_res)

  # Construct return value
  res
end

def is_biconnected(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_biconnected(c_graph, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_count_reachable: no Ruby type known for type: VECTOR_INT

def is_clique(graph, candidate, directed = false)
  # Prepare input arguments
  c_graph = graph
  c_candidate = vertex_selector_to_igraph_vs_t(candidate, graph)
  c_directed = !!directed
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_clique(c_graph, c_candidate.unwrap(), c_directed, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_cliques: no Ruby type known for type: VERTEXSET_LIST

# igraph_cliques_callback: no Ruby type known for type: CLIQUE_FUNC

# igraph_clique_size_hist: no Ruby type known for type: VECTOR

# igraph_largest_cliques: no Ruby type known for type: VERTEXSET_LIST

# igraph_maximal_cliques: no Ruby type known for type: VERTEXSET_LIST

# igraph_maximal_cliques_subset: no Ruby type known for type: VERTEXSET_LIST

# igraph_maximal_cliques_callback: no Ruby type known for type: CLIQUE_FUNC

def maximal_cliques_count(graph, min_size = 0, max_size = 0)
  # Prepare input arguments
  c_graph = graph
  c_no = nil
  c_min_size = min_size
  c_max_size = max_size

  # Call wrapped function
  IgraphC.igraph_maximal_cliques_count(c_graph, c_no, c_min_size, c_max_size)

  # Prepare output arguments
  no = c_no.value

  # Construct return value
  no
end

def maximal_cliques_file(graph, res, min_size = 0, max_size = 0)
  # Prepare input arguments
  c_graph = graph
  c_res = rb__stack.enter_context(any_to_file_ptr(res, "w"))
  c_min_size = min_size
  c_max_size = max_size

  # Call wrapped function
  IgraphC.igraph_maximal_cliques_file(c_graph, c_res, c_min_size, c_max_size)
end

# igraph_maximal_cliques_hist: no Ruby type known for type: VECTOR

def clique_number(graph)
  # Prepare input arguments
  c_graph = graph
  c_no = nil

  # Call wrapped function
  IgraphC.igraph_clique_number(c_graph, c_no)

  # Prepare output arguments
  no = c_no.value

  # Construct return value
  no
end

# igraph_weighted_cliques: no Ruby type known for type: VERTEXWEIGHTS

# igraph_largest_weighted_cliques: no Ruby type known for type: VERTEXWEIGHTS

# igraph_weighted_clique_number: no Ruby type known for type: VERTEXWEIGHTS

def is_independent_vertex_set(graph, candidate)
  # Prepare input arguments
  c_graph = graph
  c_candidate = vertex_selector_to_igraph_vs_t(candidate, graph)
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_independent_vertex_set(c_graph, c_candidate.unwrap(), c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_independent_vertex_sets: no Ruby type known for type: VERTEXSET_LIST

# igraph_largest_independent_vertex_sets: no Ruby type known for type: VERTEXSET_LIST

# igraph_maximal_independent_vertex_sets: no Ruby type known for type: VERTEXSET_LIST

def independence_number(graph)
  # Prepare input arguments
  c_graph = graph
  c_no = nil

  # Call wrapped function
  IgraphC.igraph_independence_number(c_graph, c_no)

  # Prepare output arguments
  no = c_no.value

  # Construct return value
  no
end

# igraph_layout_random: no Ruby type known for type: MATRIX

# igraph_layout_circle: no Ruby type known for type: MATRIX

# igraph_layout_star: no Ruby type known for type: MATRIX

# igraph_layout_grid: no Ruby type known for type: MATRIX

# igraph_layout_grid_3d: no Ruby type known for type: MATRIX

# igraph_layout_fruchterman_reingold: no Ruby type known for type: MATRIX

# igraph_layout_kamada_kawai: no Ruby type known for type: MATRIX

# igraph_layout_lgl: no Ruby type known for type: MATRIX

# igraph_layout_reingold_tilford: no Ruby type known for type: MATRIX

# igraph_layout_reingold_tilford_circular: no Ruby type known for type: MATRIX

def roots_for_tree_layout(graph, heuristic, mode = NeighborMode::OUT)
  # Prepare input arguments
  c_graph = graph
  c_mode = mode
  c_roots = _VectorInt.create(0)
  c_heuristic = heuristic

  # Call wrapped function
  IgraphC.igraph_roots_for_tree_layout(c_graph, c_mode, c_roots, c_heuristic)

  # Prepare output arguments
  roots = igraph_vector_int_t_to_numpy_array(c_roots)

  # Construct return value
  roots
end

# igraph_layout_random_3d: no Ruby type known for type: MATRIX

# igraph_layout_sphere: no Ruby type known for type: MATRIX

# igraph_layout_fruchterman_reingold_3d: no Ruby type known for type: MATRIX

# igraph_layout_kamada_kawai_3d: no Ruby type known for type: MATRIX

# igraph_layout_graphopt: no Ruby type known for type: MATRIX

# igraph_layout_drl: no Ruby type known for type: MATRIX

# igraph_layout_drl_3d: no Ruby type known for type: MATRIX

# igraph_layout_merge_dla: no Ruby type known for type: GRAPH_PTR_LIST

# igraph_layout_sugiyama: no Ruby type known for type: MATRIX

# igraph_layout_mds: no Ruby type known for type: MATRIX

# igraph_layout_bipartite: no Ruby type known for type: MATRIX

# igraph_layout_gem: no Ruby type known for type: MATRIX

# igraph_layout_davidson_harel: no Ruby type known for type: MATRIX

# igraph_layout_umap: no Ruby type known for type: MATRIX

# igraph_layout_umap_3d: no Ruby type known for type: MATRIX

# igraph_layout_umap_compute_weights: no Ruby type known for type: VECTOR

# igraph_cocitation: no Ruby type known for type: MATRIX

# igraph_bibcoupling: no Ruby type known for type: MATRIX

# igraph_similarity_dice: no Ruby type known for type: MATRIX

# igraph_similarity_dice_es: no Ruby type known for type: VECTOR

# igraph_similarity_dice_pairs: no Ruby type known for type: VECTOR

# igraph_similarity_inverse_log_weighted: no Ruby type known for type: MATRIX

# igraph_similarity_jaccard: no Ruby type known for type: MATRIX

# igraph_similarity_jaccard_es: no Ruby type known for type: VECTOR

# igraph_similarity_jaccard_pairs: no Ruby type known for type: VECTOR

# igraph_compare_communities: no Ruby type known for type: VECTOR_INT

# igraph_community_spinglass: no Ruby type known for type: EDGEWEIGHTS

# igraph_community_spinglass_single: no Ruby type known for type: EDGEWEIGHTS

# igraph_community_walktrap: no Ruby type known for type: EDGEWEIGHTS

# igraph_community_edge_betweenness: no Ruby type known for type: VECTOR_INT

# igraph_community_eb_get_merges: no Ruby type known for type: EDGEWEIGHTS

# igraph_community_fastgreedy: no Ruby type known for type: EDGEWEIGHTS

# igraph_community_to_membership: no Ruby type known for type: MATRIX_INT

# igraph_le_community_to_membership: no Ruby type known for type: MATRIX_INT

# igraph_modularity: no Ruby type known for type: VECTOR_INT

# igraph_modularity_matrix: no Ruby type known for type: EDGEWEIGHTS

# igraph_reindex_membership: no Ruby type known for type: VECTOR_INT

# igraph_community_leading_eigenvector: no Ruby type known for type: EDGEWEIGHTS

# igraph_community_fluid_communities: no Ruby type known for type: VECTOR_INT

# igraph_community_label_propagation: no Ruby type known for type: VECTOR_INT

# igraph_community_multilevel: no Ruby type known for type: EDGEWEIGHTS

# igraph_community_optimal_modularity: no Ruby type known for type: VECTOR_INT

# igraph_community_leiden: no Ruby type known for type: EDGEWEIGHTS

# igraph_split_join_distance: no Ruby type known for type: VECTOR_INT

# igraph_community_infomap: no Ruby type known for type: EDGEWEIGHTS

# igraph_community_voronoi: no Ruby type known for type: VECTOR_INT

# igraph_graphlets: no Ruby type known for type: EDGEWEIGHTS

# igraph_graphlets_candidate_basis: no Ruby type known for type: EDGEWEIGHTS

# igraph_graphlets_project: no Ruby type known for type: EDGEWEIGHTS

# igraph_hrg_fit: no Ruby type known for type: HRG

# igraph_hrg_sample: no Ruby type known for type: HRG

# igraph_hrg_sample_many: no Ruby type known for type: HRG

# igraph_hrg_game: no Ruby type known for type: HRG

# igraph_hrg_consensus: no Ruby type known for type: VECTOR_INT

# igraph_hrg_predict: no Ruby type known for type: VECTOR

# igraph_hrg_create: no Ruby type known for type: HRG

# igraph_hrg_resize: no Ruby type known for type: HRG

# igraph_hrg_size: no Ruby type known for type: HRG

# igraph_from_hrg_dendrogram: no Ruby type known for type: HRG

# igraph_get_adjacency: no Ruby type known for type: MATRIX

# igraph_get_adjacency_sparse: no Ruby type known for type: SPARSEMAT

# igraph_get_edgelist: no Ruby type known for type: VECTOR_INT

# igraph_get_stochastic: no Ruby type known for type: MATRIX

# igraph_get_stochastic_sparse: no Ruby type known for type: SPARSEMAT

def to_directed(graph, mode = ToDirected::MUTUAL)
  # Prepare input arguments
  c_graph = graph
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_to_directed(c_graph, c_mode)
end

def to_undirected(graph, mode = ToUndirected::COLLAPSE, edge_attr_comb = None)
  # Prepare input arguments
  c_graph = graph
  c_mode = mode
  c_edge_attr_comb = mapping_to_attribute_combination_t(edge_attr_comb)

  # Call wrapped function
  IgraphC.igraph_to_undirected(c_graph, c_mode, c_edge_attr_comb)
end

def read_graph_edgelist(instream, n_ = 0, directed = true)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_instream = rb__stack.enter_context(any_to_file_ptr(instream, "r"))
  c_n = n_
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_read_graph_edgelist(c_graph, c_instream, c_n, c_directed)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_read_graph_ncol: no Ruby type known for type: VECTOR_STR

# igraph_read_graph_lgl: no Ruby type known for type: ADD_WEIGHTS

def read_graph_pajek(instream)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_instream = rb__stack.enter_context(any_to_file_ptr(instream, "r"))

  # Call wrapped function
  IgraphC.igraph_read_graph_pajek(c_graph, c_instream)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def read_graph_graphml(instream, index = 0)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_instream = rb__stack.enter_context(any_to_file_ptr(instream, "r"))
  c_index = index

  # Call wrapped function
  IgraphC.igraph_read_graph_graphml(c_graph, c_instream, c_index)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_read_graph_dimacs_flow: no Ruby type known for type: VECTOR_STR

def read_graph_graphdb(instream, directed = false)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_instream = rb__stack.enter_context(any_to_file_ptr(instream, "r"))
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_read_graph_graphdb(c_graph, c_instream, c_directed)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def read_graph_gml(instream)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_instream = rb__stack.enter_context(any_to_file_ptr(instream, "r"))

  # Call wrapped function
  IgraphC.igraph_read_graph_gml(c_graph, c_instream)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def read_graph_dl(instream, directed = true)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_instream = rb__stack.enter_context(any_to_file_ptr(instream, "r"))
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_read_graph_dl(c_graph, c_instream, c_directed)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

def write_graph_edgelist(graph, outstream)
  # Prepare input arguments
  c_graph = graph
  c_outstream = rb__stack.enter_context(any_to_file_ptr(outstream, "w"))

  # Call wrapped function
  IgraphC.igraph_write_graph_edgelist(c_graph, c_outstream)
end

def write_graph_ncol(graph, outstream, names = "name", weights = "weight")
  # Prepare input arguments
  c_graph = graph
  c_outstream = rb__stack.enter_context(any_to_file_ptr(outstream, "w"))
  c_names = names.encode("utf-8")
  c_weights = weights.encode("utf-8")

  # Call wrapped function
  IgraphC.igraph_write_graph_ncol(c_graph, c_outstream, c_names, c_weights)
end

def write_graph_lgl(graph, outstream, names = "name", weights = "weight", isolates = true)
  # Prepare input arguments
  c_graph = graph
  c_outstream = rb__stack.enter_context(any_to_file_ptr(outstream, "w"))
  c_names = names.encode("utf-8")
  c_weights = weights.encode("utf-8")
  c_isolates = !!isolates

  # Call wrapped function
  IgraphC.igraph_write_graph_lgl(c_graph, c_outstream, c_names, c_weights, c_isolates)
end

def write_graph_leda(graph, outstream, names = "name", weights = "weight")
  # Prepare input arguments
  c_graph = graph
  c_outstream = rb__stack.enter_context(any_to_file_ptr(outstream, "w"))
  c_names = names.encode("utf-8")
  c_weights = weights.encode("utf-8")

  # Call wrapped function
  IgraphC.igraph_write_graph_leda(c_graph, c_outstream, c_names, c_weights)
end

def write_graph_graphml(graph, outstream, prefixattr = true)
  # Prepare input arguments
  c_graph = graph
  c_outstream = rb__stack.enter_context(any_to_file_ptr(outstream, "w"))
  c_prefixattr = !!prefixattr

  # Call wrapped function
  IgraphC.igraph_write_graph_graphml(c_graph, c_outstream, c_prefixattr)
end

def write_graph_pajek(graph, outstream)
  # Prepare input arguments
  c_graph = graph
  c_outstream = rb__stack.enter_context(any_to_file_ptr(outstream, "w"))

  # Call wrapped function
  IgraphC.igraph_write_graph_pajek(c_graph, c_outstream)
end

# igraph_write_graph_dimacs_flow: no Ruby type known for type: VECTOR

# igraph_write_graph_gml: no Ruby type known for type: WRITE_GML_SW

def write_graph_dot(graph, outstream)
  # Prepare input arguments
  c_graph = graph
  c_outstream = rb__stack.enter_context(any_to_file_ptr(outstream, "w"))

  # Call wrapped function
  IgraphC.igraph_write_graph_dot(c_graph, c_outstream)
end

# igraph_motifs_randesu: no Ruby type known for type: VECTOR

# igraph_motifs_randesu_estimate: no Ruby type known for type: VECTOR

# igraph_motifs_randesu_no: no Ruby type known for type: VECTOR

def dyad_census(graph)
  # Prepare input arguments
  c_graph = graph
  c_mut = nil
  c_asym = nil
  c_null = nil

  # Call wrapped function
  IgraphC.igraph_dyad_census(c_graph, c_mut, c_asym, c_null)

  # Prepare output arguments
  mut = c_mut.value
  asym = c_asym.value
  null = c_null.value

  # Construct return value
  return mut, asym, null
end

# igraph_triad_census: no Ruby type known for type: VECTOR

# igraph_adjacent_triangles: no Ruby type known for type: VECTOR

# igraph_local_scan_0: no Ruby type known for type: VECTOR

# igraph_local_scan_0_them: no Ruby type known for type: VECTOR

# igraph_local_scan_1_ecount: no Ruby type known for type: VECTOR

# igraph_local_scan_1_ecount_them: no Ruby type known for type: VECTOR

# igraph_local_scan_k_ecount: no Ruby type known for type: VECTOR

# igraph_local_scan_k_ecount_them: no Ruby type known for type: VECTOR

# igraph_local_scan_neighborhood_ecount: no Ruby type known for type: VECTOR

# igraph_local_scan_subset_ecount: no Ruby type known for type: VECTOR

def list_triangles(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = _VectorInt.create(0)

  # Call wrapped function
  IgraphC.igraph_list_triangles(c_graph, c_res)

  # Prepare output arguments
  res = igraph_vector_int_t_to_numpy_array(c_res)

  # Construct return value
  res
end

def disjoint_union(left, right)
  # Prepare input arguments
  c_res = RGraph::Internal::Graph.new
  c_left = left
  c_right = right

  # Call wrapped function
  IgraphC.igraph_disjoint_union(c_res, c_left, c_right)

  # Prepare output arguments
  res = RGraph::Graph.new(_wrap: c_res)

  # Construct return value
  res
end

# igraph_disjoint_union_many: no Ruby type known for type: GRAPH_PTR_LIST

def join(left, right)
  # Prepare input arguments
  c_res = RGraph::Internal::Graph.new
  c_left = left
  c_right = right

  # Call wrapped function
  IgraphC.igraph_join(c_res, c_left, c_right)

  # Prepare output arguments
  res = RGraph::Graph.new(_wrap: c_res)

  # Construct return value
  res
end

# igraph_union: no Ruby type known for type: INDEX_VECTOR

# igraph_union_many: no Ruby type known for type: GRAPH_PTR_LIST

# igraph_intersection: no Ruby type known for type: INDEX_VECTOR

# igraph_intersection_many: no Ruby type known for type: GRAPH_PTR_LIST

def difference(orig, sub)
  # Prepare input arguments
  c_res = RGraph::Internal::Graph.new
  c_orig = orig
  c_sub = sub

  # Call wrapped function
  IgraphC.igraph_difference(c_res, c_orig, c_sub)

  # Prepare output arguments
  res = RGraph::Graph.new(_wrap: c_res)

  # Construct return value
  res
end

def complementer(graph, loops = false)
  # Prepare input arguments
  c_res = RGraph::Internal::Graph.new
  c_graph = graph
  c_loops = !!loops

  # Call wrapped function
  IgraphC.igraph_complementer(c_res, c_graph, c_loops)

  # Prepare output arguments
  res = RGraph::Graph.new(_wrap: c_res)

  # Construct return value
  res
end

# igraph_compose: no Ruby type known for type: INDEX_VECTOR

# igraph_induced_subgraph_map: no Ruby type known for type: INDEX_VECTOR

# igraph_gomory_hu_tree: no Ruby type known for type: VECTOR

# igraph_maxflow: no Ruby type known for type: VECTOR

# igraph_maxflow_value: no Ruby type known for type: EDGE_CAPACITY

# igraph_mincut: no Ruby type known for type: EDGE_CAPACITY

# igraph_mincut_value: no Ruby type known for type: EDGE_CAPACITY

# igraph_residual_graph: no Ruby type known for type: EDGE_CAPACITY

# igraph_reverse_residual_graph: no Ruby type known for type: EDGE_CAPACITY

# igraph_st_mincut: no Ruby type known for type: EDGE_CAPACITY

# igraph_st_mincut_value: no Ruby type known for type: EDGE_CAPACITY

# igraph_st_vertex_connectivity: no Ruby type known for type: VCONNNEI

def vertex_connectivity(graph, checks = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_checks = !!checks

  # Call wrapped function
  IgraphC.igraph_vertex_connectivity(c_graph, c_res, c_checks)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def st_edge_connectivity(graph, source, target)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_source = vertexlike_to_igraph_integer_t(source)
  c_target = vertexlike_to_igraph_integer_t(target)

  # Call wrapped function
  IgraphC.igraph_st_edge_connectivity(c_graph, c_res, c_source, c_target)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def edge_connectivity(graph, checks = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_checks = !!checks

  # Call wrapped function
  IgraphC.igraph_edge_connectivity(c_graph, c_res, c_checks)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def edge_disjoint_paths(graph, source, target)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_source = vertexlike_to_igraph_integer_t(source)
  c_target = vertexlike_to_igraph_integer_t(target)

  # Call wrapped function
  IgraphC.igraph_edge_disjoint_paths(c_graph, c_res, c_source, c_target)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def vertex_disjoint_paths(graph, source, target)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_source = vertexlike_to_igraph_integer_t(source)
  c_target = vertexlike_to_igraph_integer_t(target)

  # Call wrapped function
  IgraphC.igraph_vertex_disjoint_paths(c_graph, c_res, c_source, c_target)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def adhesion(graph, checks = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_checks = !!checks

  # Call wrapped function
  IgraphC.igraph_adhesion(c_graph, c_res, c_checks)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def cohesion(graph, checks = true)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_checks = !!checks

  # Call wrapped function
  IgraphC.igraph_cohesion(c_graph, c_res, c_checks)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_dominator_tree: no Ruby type known for type: INDEX_VECTOR

# igraph_all_st_cuts: no Ruby type known for type: EDGESET_LIST

# igraph_all_st_mincuts: no Ruby type known for type: EDGESET_LIST

# igraph_even_tarjan_reduction: no Ruby type known for type: EDGE_CAPACITY

def is_separator(graph, candidate)
  # Prepare input arguments
  c_graph = graph
  c_candidate = vertex_selector_to_igraph_vs_t(candidate, graph)
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_separator(c_graph, c_candidate.unwrap(), c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

def is_minimal_separator(graph, candidate)
  # Prepare input arguments
  c_graph = graph
  c_candidate = vertex_selector_to_igraph_vs_t(candidate, graph)
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_minimal_separator(c_graph, c_candidate.unwrap(), c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_all_minimal_st_separators: no Ruby type known for type: VERTEXSET_LIST

# igraph_minimum_size_separators: no Ruby type known for type: VERTEXSET_LIST

# igraph_cohesive_blocks: no Ruby type known for type: VERTEXSET_LIST

# igraph_coreness: no Ruby type known for type: VECTOR_INT

def isoclass(graph)
  # Prepare input arguments
  c_graph = graph
  c_isoclass = nil

  # Call wrapped function
  IgraphC.igraph_isoclass(c_graph, c_isoclass)

  # Prepare output arguments
  isoclass = c_isoclass.value

  # Construct return value
  isoclass
end

def isomorphic(graph1, graph2)
  # Prepare input arguments
  c_graph1 = graph1
  c_graph2 = graph2
  c_iso = nil

  # Call wrapped function
  IgraphC.igraph_isomorphic(c_graph1, c_graph2, c_iso)

  # Prepare output arguments
  iso = c_iso.value

  # Construct return value
  iso
end

# igraph_isoclass_subgraph: no Ruby type known for type: VECTOR_INT

def isoclass_create(size, number, directed = true)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_size = size
  c_number = number
  c_directed = !!directed

  # Call wrapped function
  IgraphC.igraph_isoclass_create(c_graph, c_size, c_number, c_directed)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_isomorphic_vf2: no Ruby type known for type: VERTEX_COLOR

# igraph_count_isomorphisms_vf2: no Ruby type known for type: VERTEX_COLOR

# igraph_get_isomorphisms_vf2: no Ruby type known for type: VERTEX_COLOR

def subisomorphic(graph1, graph2)
  # Prepare input arguments
  c_graph1 = graph1
  c_graph2 = graph2
  c_iso = nil

  # Call wrapped function
  IgraphC.igraph_subisomorphic(c_graph1, c_graph2, c_iso)

  # Prepare output arguments
  iso = c_iso.value

  # Construct return value
  iso
end

# igraph_subisomorphic_vf2: no Ruby type known for type: VERTEX_COLOR

# igraph_get_subisomorphisms_vf2_callback: no Ruby type known for type: VERTEX_COLOR

# igraph_count_subisomorphisms_vf2: no Ruby type known for type: VERTEX_COLOR

# igraph_get_subisomorphisms_vf2: no Ruby type known for type: VERTEX_COLOR

# igraph_canonical_permutation: no Ruby type known for type: VERTEX_COLOR

# igraph_permute_vertices: no Ruby type known for type: INDEX_VECTOR

# igraph_isomorphic_bliss: no Ruby type known for type: VERTEX_COLOR

# igraph_count_automorphisms: no Ruby type known for type: VERTEX_COLOR

# igraph_automorphism_group: no Ruby type known for type: VERTEX_COLOR

# igraph_subisomorphic_lad: no Ruby type known for type: VERTEXSET_LIST

# igraph_simplify_and_colorize: no Ruby type known for type: VECTOR_INT

def graph_count(n_, directed = false)
  # Prepare input arguments
  c_n = n_
  c_directed = !!directed
  c_count = nil

  # Call wrapped function
  IgraphC.igraph_graph_count(c_n, c_directed, c_count)

  # Prepare output arguments
  count = c_count.value

  # Construct return value
  count
end

# igraph_is_matching: no Ruby type known for type: INDEX_VECTOR

# igraph_is_maximal_matching: no Ruby type known for type: INDEX_VECTOR

# igraph_maximum_bipartite_matching: no Ruby type known for type: INDEX_VECTOR

# igraph_adjacency_spectral_embedding: no Ruby type known for type: EDGEWEIGHTS

# igraph_laplacian_spectral_embedding: no Ruby type known for type: EDGEWEIGHTS

# igraph_eigen_adjacency: no Ruby type known for type: EIGENWHICH

# igraph_power_law_fit: no Ruby type known for type: VECTOR

# igraph_sir: no Ruby type known for type: SIR_LIST

# igraph_running_mean: no Ruby type known for type: VECTOR

# igraph_random_sample: no Ruby type known for type: VECTOR_INT

# igraph_convex_hull: no Ruby type known for type: MATRIX

# igraph_dim_select: no Ruby type known for type: VECTOR

def almost_equals(a, b, eps)
  # Prepare input arguments
  c_a = a
  c_b = b
  c_eps = eps

  # Call wrapped function
  c__result = IgraphC.igraph_almost_equals(c_a, c_b, c_eps)

  # Construct return value
  c__result
end

def cmp_epsilon(a, b, eps)
  # Prepare input arguments
  c_a = a
  c_b = b
  c_eps = eps

  # Call wrapped function
  c__result = IgraphC.igraph_cmp_epsilon(c_a, c_b, c_eps)

  # Construct return value
  c__result
end

# igraph_eigen_matrix: no Ruby type known for type: MATRIX

# igraph_eigen_matrix_symmetric: no Ruby type known for type: MATRIX

# igraph_solve_lsap: no Ruby type known for type: MATRIX

def is_eulerian(graph)
  # Prepare input arguments
  c_graph = graph
  c_has_path = nil
  c_has_cycle = nil

  # Call wrapped function
  IgraphC.igraph_is_eulerian(c_graph, c_has_path, c_has_cycle)

  # Prepare output arguments
  has_path = c_has_path.value
  has_cycle = c_has_cycle.value

  # Construct return value
  return has_path, has_cycle
end

def eulerian_path(graph)
  # Prepare input arguments
  c_graph = graph
  c_edge_res = _VectorInt.create(0)
  c_vertex_res = _VectorInt.create(0)

  # Call wrapped function
  IgraphC.igraph_eulerian_path(c_graph, c_edge_res, c_vertex_res)

  # Prepare output arguments
  edge_res = igraph_vector_int_t_to_numpy_array(c_edge_res)
  vertex_res = igraph_vector_int_t_to_numpy_array(c_vertex_res)

  # Construct return value
  return edge_res, vertex_res
end

def eulerian_cycle(graph)
  # Prepare input arguments
  c_graph = graph
  c_edge_res = _VectorInt.create(0)
  c_vertex_res = _VectorInt.create(0)

  # Call wrapped function
  IgraphC.igraph_eulerian_cycle(c_graph, c_edge_res, c_vertex_res)

  # Prepare output arguments
  edge_res = igraph_vector_int_t_to_numpy_array(c_edge_res)
  vertex_res = igraph_vector_int_t_to_numpy_array(c_vertex_res)

  # Construct return value
  return edge_res, vertex_res
end

# igraph_fundamental_cycles: no Ruby type known for type: EDGESET_LIST

# igraph_minimum_cycle_basis: no Ruby type known for type: EDGESET_LIST

def is_tree(graph, mode = NeighborMode::OUT)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_root = igraph_integer_t(0)
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_is_tree(c_graph, c_res, c_root, c_mode)

  # Prepare output arguments
  res = c_res.value
  root = c_root.value

  # Construct return value
  return res, root
end

def is_forest(graph, mode = NeighborMode::OUT)
  # Prepare input arguments
  c_graph = graph
  c_res = nil
  c_roots = _VectorInt.create(0)
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_is_forest(c_graph, c_res, c_roots, c_mode)

  # Prepare output arguments
  res = c_res.value
  roots = igraph_vector_int_t_to_numpy_array(c_roots)

  # Construct return value
  return res, roots
end

# igraph_from_prufer: no Ruby type known for type: INDEX_VECTOR

# igraph_to_prufer: no Ruby type known for type: INDEX_VECTOR

# igraph_tree_from_parent_vector: no Ruby type known for type: INDEX_VECTOR

def is_complete(graph)
  # Prepare input arguments
  c_graph = graph
  c_res = nil

  # Call wrapped function
  IgraphC.igraph_is_complete(c_graph, c_res)

  # Prepare output arguments
  res = c_res.value

  # Construct return value
  res
end

# igraph_minimum_spanning_tree: no Ruby type known for type: EDGEWEIGHTS

def minimum_spanning_tree_unweighted(graph)
  # Prepare input arguments
  c_graph = graph
  c_mst = RGraph::Internal::Graph.new

  # Call wrapped function
  IgraphC.igraph_minimum_spanning_tree_unweighted(c_graph, c_mst)

  # Prepare output arguments
  mst = RGraph::Graph.new(_wrap: c_mst)

  # Construct return value
  mst
end

# igraph_minimum_spanning_tree_prim: no Ruby type known for type: EDGEWEIGHTS

def random_spanning_tree(graph, vid = nil)
  # Prepare input arguments
  c_graph = graph
  c_res = _VectorInt.create(0)
  c_vid = vertexlike_to_igraph_integer_t(vid) if vid

  # Call wrapped function
  IgraphC.igraph_random_spanning_tree(c_graph, c_res, c_vid)

  # Prepare output arguments
  res = igraph_vector_int_t_to_numpy_array(c_res)

  # Construct return value
  res
end

def tree_game(n_, directed = false, method = RandomTreeMethod::LERW)
  # Prepare input arguments
  c_graph = RGraph::Internal::Graph.new
  c_n = n_
  c_directed = !!directed
  c_method = method

  # Call wrapped function
  IgraphC.igraph_tree_game(c_graph, c_n, c_directed, c_method)

  # Prepare output arguments
  graph = RGraph::Graph.new(_wrap: c_graph)

  # Construct return value
  graph
end

# igraph_vertex_coloring_greedy: no Ruby type known for type: VERTEX_COLOR

# igraph_deterministic_optimal_imitation: no Ruby type known for type: ALL_VERTEX_QTY

# igraph_moran_process: no Ruby type known for type: EDGEWEIGHTS

# igraph_roulette_wheel_imitation: no Ruby type known for type: ALL_VERTEX_QTY

# igraph_stochastic_imitation: no Ruby type known for type: ALL_VERTEX_QTY

# igraph_convergence_degree: no Ruby type known for type: VECTOR

def has_attribute_table()
  # Call wrapped function
  c__result = IgraphC.igraph_has_attribute_table()

  # Construct return value
  c__result
end

# igraph_progress: no Ruby type known for type: EXTRA

# igraph_status: no Ruby type known for type: EXTRA

def strerror(igraph_errno)
  # Prepare input arguments
  c_igraph_errno = igraph_errno

  # Call wrapped function
  c__result = IgraphC.igraph_strerror(c_igraph_errno)

  # Prepare return value
  rb__result = bytes_to_str(c__result)

  # Construct return value
  rb__result
end

def expand_path_to_pairs(path)
  # Prepare input arguments
  c_path = iterable_vertex_indices_to_igraph_vector_int_t(path)

  # Call wrapped function
  IgraphC.igraph_expand_path_to_pairs(c_path)

  # Prepare output arguments
  path = igraph_vector_int_t_to_numpy_array(c_path)
end

def invalidate_cache(graph)
  # Prepare input arguments
  c_graph = graph

  # Call wrapped function
  IgraphC.igraph_invalidate_cache(c_graph)
end

def vertex_path_from_edge_path(graph, start, edge_path, mode = NeighborMode::OUT)
  # Prepare input arguments
  c_graph = graph
  c_start = vertexlike_to_igraph_integer_t(start)
  c_edge_path = iterable_edge_indices_to_igraph_vector_int_t(edge_path)
  c_vertex_path = _VectorInt.create(0)
  c_mode = mode

  # Call wrapped function
  IgraphC.igraph_vertex_path_from_edge_path(c_graph, c_start, c_edge_path, c_vertex_path, c_mode)

  # Prepare output arguments
  vertex_path = igraph_vector_int_t_to_numpy_array(c_vertex_path)

  # Construct return value
  vertex_path
end

def version()
  # Prepare input arguments
  c_version_string = c_char_p()
  c_major = nil
  c_minor = nil
  c_subminor = nil

  # Call wrapped function
  IgraphC.igraph_version(c_version_string, c_major, c_minor, c_subminor)

  # Prepare output arguments
  version_string = bytes_to_str(c_version_string)
  major = c_major.value
  minor = c_minor.value
  subminor = c_subminor.value

  # Construct return value
  return version_string, major, minor, subminor
end
